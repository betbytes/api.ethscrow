package user

import (
	"api.ethscrow/models"
	"api.ethscrow/utils"
	session2 "api.ethscrow/utils/session"
	"crypto/ecdsa"
	"crypto/rand"
	"crypto/sha256"
	"crypto/x509"
	"encoding/hex"
	"github.com/go-chi/chi/v5"
	"math/big"
	"net/http"
)

var Logins = make(map[string][]byte)

func RequestChallenge(w http.ResponseWriter, r *http.Request) {
	user := &models.User{}

	user.Username = chi.URLParam(r, "Username")
	if user.Username == "" {
		return
	}

	// creates a cryptographically secure 10 hex byte array
	nonce := make([]byte, 10)
	if _, err := rand.Read(nonce); err != nil {
		utils.Error(w, http.StatusInternalServerError, err.Error())
		return
	}

	// when verifying the signed data from the challenge submission, it is verified on the sha256 hash of the nonce
	h := sha256.New()
	sHash := h.Sum(nonce)

	Logins[user.Username] = sHash

	utils.JSON(w, http.StatusOK, &utils.BasicData{Data: hex.EncodeToString(sHash)})
}

// SubmitChallenge /challenge/{Username}
// submit username, r & s values of signed data, the data is generated by the server during the /challenge endpoint request
func SubmitChallenge(w http.ResponseWriter, r *http.Request) {
	user := &models.User{
		Username: chi.URLParam(r, "Username"),
	}
	if user.Username == "" {
		return
	}

	var body map[string]string

	if err := utils.ParseRequestBody(r, &body); err != nil || body["r"] == "" || body["s"] == "" {
		utils.Error(w, http.StatusBadRequest, "Invalid request.")
		return
	}

	if Logins[user.Username] == nil {
		utils.Error(w, http.StatusBadRequest, "Request a challenge first.")
		return
	}

	if exists, err := user.Exists(); err != nil || !exists {
		utils.Error(w, http.StatusNotFound, "Username doesn't exist.")
		return
	}

	rVal := new(big.Int).SetBytes(utils.DecodeHexString(body["r"]))
	sVal := new(big.Int).SetBytes(utils.DecodeHexString(body["s"]))

	key, err := x509.ParsePKIXPublicKey(utils.DecodeHexString(user.PublicKey))
	if err != nil {
		utils.Error(w, http.StatusInternalServerError, err.Error())
		return
	}

	valid := ecdsa.Verify(key.(*ecdsa.PublicKey), Logins[user.Username], rVal, sVal)
	delete(Logins, user.Username)

	if valid {
		session, _ := session2.Store.Get(r, "session.id")
		session.Values["authenticated"] = true
		session.Values["username"] = user.Username
		session.Values["enc_public_key"] = user.EncPublicKey
		if err = session.Save(r, w); err != nil {
			utils.Error(w, http.StatusInternalServerError, err.Error())
			return
		}

		utils.JSON(w, http.StatusOK, valid)
	} else {
		utils.Error(w, http.StatusForbidden, "Unauthorized.")
	}
}

func Logout(w http.ResponseWriter, r *http.Request) {
	session, _ := session2.Store.Get(r, "session.id")
	session.Values["authenticated"] = false
	session.Options.MaxAge = -1
	if err := session.Save(r, w); err != nil {
		utils.Error(w, http.StatusInternalServerError, err.Error())
		return
	}

	utils.JSON(w, http.StatusOK, "Logged out")
}
